const mongoose = require('mongoose');

const generatedDocumentSchema = new mongoose.Schema({
  documentId: {
    type: String,
    unique: true,
    required: false  // Will be generated by pre-save hook
  },
  template: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'DocumentTemplate',
    required: true
  },
  client: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'VerifiedClient',
    required: true
  },
  lawyer: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'VerifiedLawyer',
    default: null
  },
  case: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'CaseModel',
    default: null
  },
  formData: {
    type: mongoose.Schema.Types.Mixed,
    required: true
  },
  generatedContent: {
    type: String,
    required: true
  },
  documentType: {
    type: String,
    required: true
  },
  status: {
    type: String,
    enum: ['draft', 'generated', 'reviewed', 'approved', 'filed', 'rejected'],
    default: 'draft'
  },
  reviewNotes: {
    type: String,
    default: ''
  },
  reviewedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'VerifiedLawyer'
  },
  reviewedAt: {
    type: Date
  },
  approvedAt: {
    type: Date
  },
  filedAt: {
    type: Date
  },
  courtReference: {
    type: String,
    default: ''
  },
  filePath: {
    type: String,
    default: ''
  },
  downloadCount: {
    type: Number,
    default: 0
  },
  lastDownloaded: {
    type: Date
  },
  metadata: {
    wordCount: Number,
    pageCount: Number,
    fileSize: Number,
    mimeType: String
  },
  isPublic: {
    type: Boolean,
    default: false
  },
  sharingSettings: {
    allowLawyerAccess: {
      type: Boolean,
      default: true
    },
    allowClientAccess: {
      type: Boolean,
      default: true
    },
    expirationDate: Date
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes
generatedDocumentSchema.index({ client: 1, createdAt: -1 });
generatedDocumentSchema.index({ template: 1 });
generatedDocumentSchema.index({ case: 1 });
generatedDocumentSchema.index({ status: 1 });
// Note: documentId already has unique index from schema definition

// Pre-save middleware
generatedDocumentSchema.pre('save', function(next) {
  if (!this.documentId) {
    const timestamp = Date.now().toString();
    const randomStr = Math.random().toString(36).substr(2, 6).toUpperCase();
    this.documentId = `DOC-${timestamp}-${randomStr}`;
  }
  next();
});

// Method to update status
generatedDocumentSchema.methods.updateStatus = function(newStatus, notes = '', userId = null) {
  this.status = newStatus;
  
  if (notes) {
    this.reviewNotes = notes;
  }
  
  switch (newStatus) {
    case 'reviewed':
      this.reviewedBy = userId;
      this.reviewedAt = new Date();
      break;
    case 'approved':
      this.approvedAt = new Date();
      break;
    case 'filed':
      this.filedAt = new Date();
      break;
  }
  
  return this.save();
};

// Method to record download
generatedDocumentSchema.methods.recordDownload = function() {
  this.downloadCount += 1;
  this.lastDownloaded = new Date();
  return this.save();
};

// Static method to get documents by client
generatedDocumentSchema.statics.getByClient = function(clientId, options = {}) {
  const query = { client: clientId };
  
  if (options.status) {
    query.status = options.status;
  }
  
  if (options.template) {
    query.template = options.template;
  }
  
  return this.find(query)
    .populate('template', 'name category description')
    .populate('lawyer', 'name email')
    .populate('case', 'caseNumber caseType')
    .sort({ createdAt: -1 })
    .limit(options.limit || 50);
};

// Static method to get documents by lawyer
generatedDocumentSchema.statics.getByLawyer = function(lawyerId, options = {}) {
  const query = { lawyer: lawyerId };
  
  if (options.status) {
    query.status = options.status;
  }
  
  return this.find(query)
    .populate('template', 'name category description')
    .populate('client', 'name email')
    .populate('case', 'caseNumber caseType')
    .sort({ createdAt: -1 })
    .limit(options.limit || 50);
};

module.exports = mongoose.model('GeneratedDocument', generatedDocumentSchema);
